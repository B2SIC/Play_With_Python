# ******************************************************
# Name: 김영훈
# Student ID: 20171597
# Program ID: Homework #1 <Miro>
# Description: Stack 자료 구조를 이용해서 주어진 미로의 출구를 찾는다.
# 추가바람


import Stack, sys
from collections import namedtuple

# Flag Variable
found = False

# 미로 맵 데이터
# 0 ~ 16 X 0 ~ 13
maze = [
#0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 0
[1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], # 1
[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], # 2
[1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1], # 3
[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], # 4
[1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], # 5
[1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], # 6
[1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], # 7
[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 8
[1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], # 9
[1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1], # 10
[1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1], # 11
[1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1], # 12
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # 13
]

mark = [
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

# 이동 테이블을 선언 한다. (인덱스 접근 가능)
direction = namedtuple("direction", "N NE E SE S SW W NW")
move_vert = direction(-1, -1, 0, 1, 1, 1, 0, -1)
move_horiz = direction(0, 1, 1, 1, 0, -1, -1, -1)

# mark_data 에 경로를 저장하고 스택에 입구 좌표를 저장한다.
mark[1][1] = 1
Stack.push([1, 1])
# 초기 값들 지정한다.
i = 2; j = 2; d = 0
exit_row = 12
exit_col = 15
mark_log = [[1, 1]]

while(Stack.top > -1 and (not found)):
    if d > 7:
        print("Log: 길이 막혔습니다. Pop을 수행하겠습니다.")
        i, j = Stack.pop()
        print("Event(POP) :: [%d][%d]" % (i, j))
        d = 0

    while(d < 8 and (not found)):
        # 다음 이동 좌표 지정
        g = i + move_vert[d]
        h = j + move_horiz[d]

        print("Log: 다음 미로 검사 대상 좌표는 [%d][%d] 입니다." %(g, h))

        if g == exit_row and h == exit_col:
            found = True
            # 경로 출력
            print("END :: 길을 찾았습니다 !!")
            print("END :: 출구는 [%d][%d] 에 존재합니다." % (g, h))
            print("Log: 미로의 길을 알려주는 경로를 순서대로 출력하겠습니다.")

        # 새로운 길 발견 or 미로 결과 출력
        if (not maze[g][h]) and (not mark[g][h]):
            mark[g][h] = 1
            Stack.push([i, j])
            print("Event(PUSH) :: [%d %d]" % (i, j))
            tmp_i = i
            tmp_j = j
            i = g; j = h; d = 0

            # 최종 미로 결과 출력
            if i == 12 and j == 15 and found:
                print("<<<<<<<<<<<<<<<< Result >>>>>>>>>>>>>>>>>>")
                print("Path: ", end=' ')
                Stack.display_stack_reverse(g, h)
                print("========================================")
                print("Mark: ", end=' ')
                for list in mark_log:
                    print(list, end=' -> ')
                print([g, h])
            else:
                print("Log: 새로운 길을 찾았으며 다음으로 넘어가겠습니다.")
                print("Log: 이전 좌표는 [%d][%d]이며, 다음 좌표는 [%d][%d] 입니다." % (tmp_i, tmp_j, i, j))
                mark_log.append([i, j])

        else:
            d += 1
            print("Log: 길이 없으므로 방향을 바꿉니다. 현재 d의 값은 %d 입니다." % d)
